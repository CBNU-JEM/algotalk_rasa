
{
  "algorithm": [
    {
      "name": "수학",
      "brief_explain": "기본 수학적 지식을 사용해 문제를 해결하는 알고리즘이야",
      "detail_explain": "기본 수학적 지식을 사용해 문제를 해결하는 알고리즘이야.\n종류로는 기하학, 정수론, 조합론, 사칙연산 등이 있어.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "다이나믹 프로그래밍",
      "brief_explain": "복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법이야 ",
      "detail_explain": "문제를 여러 개의 하위 문제로 나누어 푼 다움, 문제의 정답을 한 번만 계산하고 저장한 뒤, 그것을 결합하여 최종적인 정답에 도달하는 방법이야\n최단경로 문제, 행렬의 제곱 문제 등의 최적화에 사용해",
      "level": "중급",
      "parent": null
    },
    {
      "name": "구현",
      "brief_explain": "풀이 과정은 생각해내기 상대적으로 쉬우나, 이를 코드로 구현함에 있어서 여러가지 장애물이 존재하는 알고리즘이야",
      "detail_explain": "완전 탐색이나 시뮬레이션 등의 방법이 있으며 구현할 때 모든 경우의 수를 생각해 보는게 중요해",
      "level": "중급",
      "parent": null
    },
    {
      "name": "그래프 이론",
      "brief_explain": "객체 간에 짝을 이루는 관계를 모델링하기 위해 사용되는 수학 구조인 그래프를 사용하는 알고리즘이야",
      "detail_explain": "그래프는 꼭짓점(vertex), 교점(node), 점(point)으로 구성되며 이것들은 간선(edge), 즉 선으로 연결되어있어.\n간선들이 방향성을 가지면 방향 그래프, 방향성이 없으면 무 방향 그래프로 나뉘어.",
      "level": "중급",
      "parent": "자료 구조"
    },
    {
      "name": "자료 구조",
      "brief_explain": "효율적인 접근 및 수정을 위해 데이터를 구조적으로 표현하는 방식과 이를 구현하는 데 필요한 알고리즘이야 ",
      "detail_explain": "효율적인 접근 및 수정을 위해 데이터를 구조적으로 표현하는 방식과 이를 구현하는 데 필요한 알고리즘이야.\n자료구조의 대표적 예시로는 배열, 연결리스트, 스택, 큐, 그래프, 트리 등이 있어.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "문자열",
      "brief_explain": "문자열을 이용해 문제를 해결하는 알고리즘이야.",
      "detail_explain": "문자열을 이용해 문제를 해결하는 알고리즘이야.\n문자열 알고리즘의 대표적 예시로는 Naive String Search 알고리즘, Finite-state automaton based search 알고리즘, KMP 알고리즘, Rabin-Karp 알고리즘 등이 있어.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "그리디 알고리즘",
      "brief_explain": "미래를 생각하지 않고 각 단계에서 가장 최선의 선택을 하는 기법이야.",
      "detail_explain": "최적해를 구하는 데에 사용되는 근사적인 방법으로, 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 방법이야.\n그리디 알고리즘은 계산속도는 빠르지만 모든 경우에 대해서 최적해를 보장하지는 않아.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "greedy",
      "brief_explain": "미래를 생각하지 않고 각 단계에서 가장 최선의 선택을 하는 기법이야.",
      "detail_explain": "최적해를 구하는 데에 사용되는 근사적인 방법으로, 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 방법이야.\n그리디 알고리즘은 계산속도는 빠르지만 모든 경우에 대해서 최적해를 보장하지는 않아.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "탐욕법",
      "brief_explain": "미래를 생각하지 않고 각 단계에서 가장 최선의 선택을 하는 기법이야.",
      "detail_explain": "최적해를 구하는 데에 사용되는 근사적인 방법으로, 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 방법이야.\n그리디 알고리즘은 계산속도는 빠르지만 모든 경우에 대해서 최적해를 보장하지는 않아.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "그래프 탐색",
      "brief_explain": "자료구조인 그래프를 탐색하는 알고리즘이야.",
      "detail_explain": "자료구조인 그래프를 탐색하는 알고리즘이야.\n대표적인 방법으로 DFS(Depth First Search)와 BFS(Beside Fisrt Search) 알고리즘으로 나뉘어.",
      "level": "초급",
      "parent": "그래프 이론"
    },
    {
      "name": "브루트포스 알고리즘",
      "brief_explain": "문제를 해결하기 위한 모든 방법을 하나씩 대입해 보는 방식으로 해결하는 알고리즘이야",
      "detail_explain": "문제를 해결하기 위한 모든 방법을 하나씩 대입해 보는 방식으로 해결하는 알고리즘이야.\n 많은 시간이 걸리지만 모든 경우의 수를 탐색하므로 100% 답을 찾는게 가능해.",
      "level": "초급",
      "parent": null
    },
    {
      "name": "세그먼트 트리",
      "brief_explain": "저장된 자료를 적절히 구간별로 전처리해 그들에 대한 질의들을 빠르게 대답할 수 있도록 해주는 트리야.",
      "detail_explain": "저장된 자료를 적절히 구간별로 전처리해 그들에 대한 질의들을 빠르게 대답할 수 있도록 해주는 트리야.\n특정 구간에 대한 정보가 필요한 경우 빠른시간에 정보를 구할 수 있어. 트리를 만드는데 O(NlogN), 정보를 구하는데 O(logN)의 시간이 걸려.",
      "level": "고급",
      "parent": "트리"
    },
    {
      "name": "트리",
      "brief_explain": "그래프 자료구조의 한 종류로 각 노드들이 서로 다른 자식을 갖는 구조야.",
      "detail_explain": "그래프 자료구조의 한 종류로 각 노드들이 서로 다른 자식을 갖는 구조야.\n트리에서 최상위 노드를 루트 노드라고 불러. 노드 A가 노드 B를 가리킬 때 A를 B의 부모 노드, B를 A의 자식 노드라고 해. 자식 노드가 없는 노드를 잎 노드라고 하고, 잎 노드가 아닌 노드를 내부 노드라고 해.\n트리의 종류로는 이진 트리, B 트리, 포레스트, 트라이 등이 있어",
      "level": "중급",
      "parent": null
    },
    {
      "name": "이분 탐색",
      "brief_explain": "오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘이야.",
      "detail_explain": "오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘이야.\n처음 중간의 값을 임의의 값으로 선택하여, 그 값과 찾고자 하는 값의 크고 작음을 비교하는 방식이야. 처음 선택한 중앙값이 만약 찾는 값보다 크면 그 값은 새로운 최댓값이 되며, 작으면 그 값은 새로운 최솟값이 돼. 검색 원리상 정렬된 리스트에만 사용할 수 있다는 단점이 있지만, 검색이 반복될 때마다 목표값을 찾을 확률은 두 배가 되므로 속도가 빨라.\n시간복잡도는 O(logN)이야.",
      "level": "초급",
      "parent": null
    },
    {
      "name": "기하학",
      "brief_explain": "공간에 있는 도형의 성질, 대상들의 치수, 모양, 상대적 위치를 이용하는 알고리즘이야.",
      "detail_explain": "공간에 있는 도형의 성질, 대상들의 치수, 모양, 상대적 위치를 이용하는 알고리즘이야.\n기하학의 예시로는 선분교차, 직각 삼각형, 내접 다각형, 순황 외판원, CAD, 최소 신장 트리 등이 있어.",
      "level": "중급",
      "parent": "수학"
    },
    {
      "name": "정수론",
      "brief_explain": "각종 수의 성질을 이용하는 알고리즘이야.",
      "detail_explain": "각종 수의 성질을 이용하는 알고리즘이야.\n정수론의 예시로는 최대공약수, 최소공배수, 에라토스테네스의 체, 거듭제곱의 연산 등이 있어.",
      "level": "중급",
      "parent": "수학"
    },
    {
      "name": "너비 우선 탐색",
      "brief_explain": "시작 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법이야.",
      "detail_explain": "시작 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법이야.\n출발노드에서 목표노드까지의 최단 길이 경로를 보장하지만 경로가 매우 길 경우에는 탐색 가지가 급격히 증가함에 따라 보다 많은 기억 공간을 필요로 해.\n시간복잡도는 인접 리스트를 사용하면 O(longV+E), 인접 행렬을 사용하면 O(logV^2)이야(V=정점의 수,E=간선의 수)",
      "level": "초급",
      "parent": "그래프 탐색"
    },
    {
      "name": "조합론",
      "brief_explain": "경우의 수를 이용하는 알고리즘이야.",
      "detail_explain": "경우의 수를 이용하는 알고리즘이야.\n순열과 조합,경우의 수가 조합론에 속해.",
      "level": "중급",
      "parent": "수학"
    },
    {
      "name": "사칙연산",
      "brief_explain": "산수의 기본이 되는 덧셈, 뺄셈, 곱셈, 나눗셈의 4가지 연산을 이용하는 알고리즘이야.",
      "detail_explain": "덧셈, 뺄셈, 곱셈, 나눗셈의 4가지 연산을 정확하게 작동하도록 구현하는게 중요해.",
      "level": "초급",
      "parent": "수학"
    },
    {
      "name": "누적 합",
      "brief_explain": "구간의 누적합을 계산해 문제를 해결하는 알고리즘이야.",
      "detail_explain": "구간의 누적합을 계산해 문제를 해결하는 알고리즘이야.\n배열을 부분 합을 빠르게 구해야 하는 경우 시간복잡도 O(N)으로 구할 수 있어.",
      "level": "초급",
      "parent": null
    },
    {
      "name": "깊이 우선 탐색",
      "brief_explain": "탐색하다가 특정 정점에서 최대한 깊숙히 들어가서 확인한 뒤 다시 돌아가 다른 루트로 탐색하는 방법이야.",
      "detail_explain": "탐색하다가 특정 정점에서 최대한 깊숙히 들어가서 확인한 뒤 다시 돌아가 다른 루트로 탐색하는 방법이야\n단지 현 경로상의 노드들만을 기억하면 되므로 저장공간의 수요가 비교적 적고, 목표노드가 깊은 단계에 있을 경우 해를 빨리 구할 수 있지만 최단경로를 보장하지 않는다.\n시간복잡도는 인접 리스트를 사용하면 O(longV+E), 인접 행렬을 사용하면 O(logV^2)이야(V=정점의 수,E=간선의 수)",
      "level": "초급",
      "parent": "그래프 탐색"
    },
    {
      "name": "시뮬레이션",
      "brief_explain": "일련의 명령에 따라서 개체를 차례대로 이동시키는 방법으로 해결하는 알고리즘이야.",
      "detail_explain": "일련의 명령에 따라서 개체를 차례대로 이동시키는 방법으로 해결하는 알고리즘이야.\n 문제를 세분화해서 작은 단계를 해결하는 과정을 반복하며 문제를 접근해야해.",
      "level": "중급",
      "parent": "구현"
    },
    {
      "name": "다익스트라",
      "brief_explain": "그래프에서 꼭짓점 간의 최단 경로를 찾는 알고리즘이야.",
      "detail_explain": "하나의 노드로부터 최단경로를 구하는 알고리즘으로 그래프 방향의 유무는 상관 없으나, 간선들 중 단 하나라도 가중치가 음수이면 이 알고리즘은 사용할 수 없어.\n출발점에서 최단거리를 저장할 배열을 만들고 출발점은 0, 다른 점에는 매우 큰 값으로 채운다음, 현재 점으로 출발점을 선택해.\n현재 점에서 갈 수 있는 길이를 비교해 작으면 갱신시키는 방법으로 구현할 수 있어. \n시간 복잡도는 우선순위 큐를 사용하면 O(ElogV), 사용하지 않으면 O(V^2 + E)야. (V=정점의 수,E=간선의 수)",
      "level": "중급",
      "parent": null
    },
    {
      "name": "비트마스킹",
      "brief_explain": "0 과 1로 이루어진 bit를 이용해 문제를 해결하는 알고리즘이야.",
      "detail_explain": "0 과 1로 이루어진 bit를 이용해 문제를 해결하는 알고리즘이야.\nbit 의 AND, OR, NOT, XOR, SHIFT 연산 등을 사용하여 문제를 해결해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "분리 집합",
      "brief_explain": "교집합이 존재하지 않는 둘 이상의 데이터 집합을 다루는 알고리즘이야.",
      "detail_explain": "교집합이 존재하지 않는 둘 이상의 데이터 집합을 다루는 알고리즘이야.\n자식노드가 부모 노드를 가르키는 형태이며 트리를 사용해 구현해.\n시간복잡도는 만드는데 O(logN), 찾는데 O(logN)이야.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "분할 정복",
      "brief_explain": "해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법이야.",
      "detail_explain": "해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법이야.\n재귀 함수나 반복문을 통해 구현가능하며 퀵소트, 머지소트, 고속 푸리에 변환등에 사용해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "애드 혹",
      "brief_explain": "해당 문제를 풀기 위해 잘 알려진 정교한 알고리즘을 적용하지 않고 해결할 수 있는 유형의 문제야.",
      "detail_explain": "해당 문제를 풀기 위해 잘 알려진 정교한 알고리즘을 적용하지 않고 해결할 수 있는 유형의 문제야.\n단순히 지시를 따르면 되는 구현 유형이나 그리디 유형 알고리즘 혹은 수학 유형으로 분류해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "구성적",
      "brief_explain": " 답을 증명할 수 있는 실제 예시를 구성하는 알고리즘이야.",
      "detail_explain": "귀류법이나 귀납법을 쓰지 않고 직접 조건을 만족하는 예시를 만들어 증명하는 방법이야.\n무에서 유를 창조해내야 하는 문제의 특성상, 많은 배경 지식이 필요하고 풀이의 논리적 흐름을 찾는 것이 중요해.",
      "level": "고급",
      "parent": null
    },
    {
      "name": "백트래킹",
      "brief_explain": "해를 찾아가는 도중, 지금의 경로가 해가 될 것 같지 않으면 그 경로를 더이상 가지 않고 되돌아가는 방법이야.",
      "detail_explain": "해를 찾아가는 도중, 지금의 경로가 해가 될 것 같지 않으면 그 경로를 더이상 가지 않고 되돌아가는 방법이야.\n모든 경우의 수를 탐색하는 과정에서, 조건문 등을 걸어 답이 절대로 될 수 없는 상황을 정의하고, 그러한 상황일 경우에는 탐색을 중지시킨 뒤 그 이전으로 돌아가서 다시 다른 경우를 탐색하게끔 구현해.",
      "level": "초급",
      "parent": null
    },
    {
      "name": "스위핑",
      "brief_explain": "단어의 뜻 그대로 휩쓸고 지나가며 문제를 해결하는 방식으로, 특정 기준에 따라 정렬한 후 순서대로 처리하는 알고리즘이야.",
      "detail_explain": "특정 기준에 따라 정렬한 후 순서대로 처리하는 알고리즘이야.\n스위핑 알고리즘을 사용해야하는 문제들의 특징은 완전탐색으로는 해결이 불가능하며, DP를 사용하기에는 메모이제이션 해야할 수가 너무 많은 경우가 일반적이야.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "Case work",
      "brief_explain": "조건분기를 나눠서 문제를 해결하는 방법이야.",
      "detail_explain": "문제를 해결할때 브루트포스로 접근하면 시간이 초과되어 case를 나눠서 문제를 해결하는 방법이야. ",
      "level": "중급",
      "parent": null
    },
    {
      "name": "스택",
      "brief_explain": "언제나 목록의 끝에서만 제한적으로 접근할 수 있는 자료구조야.",
      "detail_explain": "언제나 목록의 끝에서만 제한적으로 접근할 수 있는 자료구조야.\n스택의 가장 윗 데이터 자리 위에 데이터를 생성하는 PUSH 연산과 가장 윗 데이터를 삭제하는 POP연산이 있어.\n맨 위에 데이터만 접근하므로 시간복잡도는 O(1)이야.",
      "level": "초급",
      "parent": null
    },
    {
      "name": "우선순위 큐",
      "brief_explain": "각 원소들이 우선순위를 갖고 있는 큐, 높은 우선순위를 가진 원소는 낮은 우선순위를 가진 원소보다 먼저 처리된는 큐야.",
      "detail_explain": "각 원소들이 우선순위를 갖고 있는 큐, 높은 우선순위를 가진 원소는 낮은 우선순위를 가진 원소보다 먼저 처리된는 큐야.\n시간복잡도는 O(logn)이야",
      "level": "중급",
      "parent": null
    },
    {
      "name": "트리에서의 다이나믹 프로그래밍",
      "brief_explain": "트리라는 그래프 자료구조에서 다이나믹 프로그래밍 기법을 적용한 방법이야.",
      "detail_explain": "트리라는 그래프 자료구조에서 다이나믹 프로그래밍 기법을 적용한 방법이야.\n 기본적으로 Top-down 방식으로 DFS를 통해 순회한 뒤, 노드들의 값을 알아내는 방식으로 구현해. ",
      "level": "중급",
      "parent": null
    },
    {
      "name": "최대 유량",
      "brief_explain": "네트워크 흐름에서 유량을 최대화 하는 알고리즘이야.",
      "detail_explain": "네트워크 흐름에서 유량을 최대화 하는 알고리즘이야.\n대표적인 알고리즘으로 Ford–Fulkerson 알고리즘과 Edmonds-Karp 알고리즘이 있어.",
      "level": "고급",
      "parent": null
    },
    {
      "name": "파싱",
      "brief_explain": "입력 문장의 구조를 분석하여 해결하는 알고리즘이야.",
      "detail_explain": "입력 문장의 구조를 분석하여 해결하는 알고리즘이야.\n대표적인 파싱 알고리즘으로 CYK 알고리즘,LALR, LL파서, 재귀 하향 파서 등이 있다.",
      "level": "고급",
      "parent": null
    },
    {
      "name": "느리게 갱신되는 세그먼트 트리",
      "brief_explain": "세그먼트 트리에서 모든 값을 그때그때 갱신하지 않고 각 노드마다 lazy 값을 두어 노드를 방문할 일이 생길때 갱신하는 방법이야.",
      "detail_explain": "세그먼트 트리에서 모든 값을 그때그때 갱신하지 않고 각 노드마다 lazy 값을 두어 노드를 방문할 일이 생길때 갱신하는 방법이야.\n 일반적인 세그먼트 트리의 쿼리연산은 같으나 업데이트 연산시 lazy 값을 확인하여 반영하는 방식으로 구현해.",
      "level": "고급",
      "parent": null
    },
    {
      "name": "투 포인터",
      "brief_explain": "1차원 배열에서 두 개의 포인터를 조작하여 원하는 결과를 얻는 알고리즘이야.",
      "detail_explain": "1차원 배열에서 두 개의 포인터를 조작하여 원하는 결과를 얻는 알고리즘이야.\n시작점 L 과 R 두개를 선언하고 R를 한칸씩 이동시키면서 답을 찾으면 L를 한칸 이동시는 방식으로 구현해.\n시간복잡도는 O(n)이야.",
      "level": "초급",
      "parent": null
    },
    {
      "name": "비트필드를 이용한 다이나믹 프로그래밍",
      "brief_explain": "DP 배열을 비트필드를 이용해 채우는 방법이야.",
      "detail_explain": "일반적인 방법으론 배열의 크기를 감당할 수 없을 때 비트필드를 사용해 배열의 크기를 줄인 후 다이나믹 프로그래밍 기법을 적용하는 방식이야.",
      "level": "중급",
      "parent": "다이나믹 프로그래밍"
    },
    {
      "name": "트리를 사용한 집합과 맵",
      "brief_explain": "트리 자료구조를 사용해서 집합이나 맵을 구현하는 알고리즘이야.",
      "detail_explain": "트리 자료구조를 사용해서 집합이나 맵을 구현하는 알고리즘이야.\n 이진트리를 구현해서 O(logN)의 시간으로 집합이나 맵을 구현하는 방식이야.",
      "level": "중급",
      "parent": "트리"
    },
    {
      "name": "소수 판정",
      "brief_explain": "어떤 자연수 N이 소수인지 합성수인지를 판별하는 알고리즘이야.",
      "detail_explain": "어떤 자연수 N이 소수인지 합성수인지를 판별하는 알고리즘이야.\n대표적인 알고리즘으로 윌슨의 정리, 페르마 소수판별법 등이 있다.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "오프라인 쿼리",
      "brief_explain": "쿼리를 받아서 매번 처리하려다 보면 어떤 수를 써도 빠르게 다 대처할 수가 없을 때, 오프라인으로 쿼리는 처리하는 방법이야.",
      "detail_explain": "쿼리를 받아서 매번 처리하려다 보면 어떤 수를 써도 빠르게 다 대처할 수가 없을 때, 오프라인으로 쿼리는 처리하는 방법이야.\n쿼리를 바로바로 처리하지 않고 쿼리를 재배열해서 풀거나 미리 쿼리를 보고 전처리해서 푸는 유형이 있어.",
      "level": "고급",
      "parent": null
    },
    {
      "name": "게임 이론",
      "brief_explain": "상호 의존적이고 이성적인 의사결정에 관한 수학적 이론을 통해 구현하는 알고리즘이야.",
      "detail_explain": "상호 의존적이고 이성적인 의사결정에 관한 수학적 이론을 통해 구현하는 알고리즘이야.\n 문제가 주어졌을 때 이길 수 있는 상황이 나오는지, 필승법이 있는지를 찾아야해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "분할 정복을 이용한 거듭제곱",
      "brief_explain": "일반적인 방법으로 거듭제곱을 계산하면 O(N)의 시간이 걸리지만 분할정복을 통해 O(logN)의 시간으로 거듭제곱을 구하는 알고리즘이야.",
      "detail_explain": "일반적인 방법으로 거듭제곱을 계산하면 O(N)의 시간이 걸리지만 분할정복을 통해 O(logN)의 시간으로 거듭제곱을 구하는 알고리즘이야.\n 재귀나 반복문을 사용해 구현해.",
      "level": "중급",
      "parent": "재귀"
    },
    {
      "name": "이분 매칭",
      "brief_explain": "이분 그래프에서 A 그룹의 정점에서 B 그룹의 정점으로 간선을 연결 할 때,A그래프의 하나의 정점이 B그래프 하나의 정점만 가지도록 하는 알고리즘이야.",
      "detail_explain": "이분 그래프에서 A 그룹의 정점에서 B 그룹의 정점으로 간선을 연결 할 때,A그래프의 하나의 정점이 B그래프 하나의 정점만 가지도록 하는 알고리즘이야.\n dfs를 이용해서 이분 매칭을 해결할 수 있어. 이 경우 시간복잡도는 O(V*E)야 (V=정점,E=간선)",
      "level": "중급",
      "parent": null
    },
    {
      "name": "임의 정밀도 / 큰 수 연산",
      "brief_explain": "기본적으로 제공하는 데이터 타입보다 큰 수를 연산하는 알고리즘이야.",
      "detail_explain": "기본적으로 제공하는 데이터 타입보다 큰 수를 연산하는 알고리즘이야.\n 분할정복 방법을 통해 큰 수의 자리 수를 나눠 계산한 후 자리 올림과 자리 내림을 통해 연산을 구현해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "최소 스패닝 트리",
      "brief_explain": "가장 적은 간선을 갖는 그래프 내의 모든 정점을 포함하는 트리야.",
      "detail_explain": "가장 적은 간선을 갖는 그래프 내의 모든 정점을 포함하는 트리야.\nDFS, BFS을 이용하여 탐색 도중에 사용된 간선만 모으면 그래프에서 스패닝 트리를 찾을 수 있어.\n스패닝 트리는 트리의 특수한 형태이므로 모든 정점들이 연결 되어 있어야 하고 사이클을 포함하지 않아. 따라서 스패닝 트리는 그래프에 있는 n개의 정점을 정확히 (n-1)개의 간선으로 연결 해야해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "최소신장트리",
      "brief_explain": "가장 적은 간선을 갖는 그래프 내의 모든 정점을 포함하는 트리야.",
      "detail_explain": "가장 적은 간선을 갖는 그래프 내의 모든 정점을 포함하는 트리야.\nDFS, BFS을 이용하여 탐색 도중에 사용된 간선만 모으면 그래프에서 스패닝 트리를 찾을 수 있어.\n스패닝 트리는 트리의 특수한 형태이므로 모든 정점들이 연결 되어 있어야 하고 사이클을 포함하지 않아. 따라서 스패닝 트리는 그래프에 있는 n개의 정점을 정확히 (n-1)개의 간선으로 연결 해야해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "미니멈스패닝트리",
      "brief_explain": "가장 적은 간선을 갖는 그래프 내의 모든 정점을 포함하는 트리야.",
      "detail_explain": "가장 적은 간선을 갖는 그래프 내의 모든 정점을 포함하는 트리야.\nDFS, BFS을 이용하여 탐색 도중에 사용된 간선만 모으면 그래프에서 스패닝 트리를 찾을 수 있어.\n스패닝 트리는 트리의 특수한 형태이므로 모든 정점들이 연결 되어 있어야 하고 사이클을 포함하지 않아. 따라서 스패닝 트리는 그래프에 있는 n개의 정점을 정확히 (n-1)개의 간선으로 연결 해야해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "해싱",
      "brief_explain": "임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 알고리즘이야",
      "detail_explain": "임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 알고리즘이야\n매핑전 원래 데이터 값을 키, 매핑후 데이터 값을 해시값 이라고 해.\n적은 리소스로 많은 데이터를 효율적으로 관리 할 수 있지만, 여러 키가 해시값이 같은 해시 충돌이 발생 할 수 있어.\n시간복잡도는 O(1)이야.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "최소 공통 조상",
      "brief_explain": "트리상에서 어떤 두 정점 u, v가 있을 때, u이거나 u의 조상이면서 동시에 v이거나 v의 조상인 노드들 중 가장 깊은 노드를 찾는 알고리즘이야.",
      "detail_explain": "트리상에서 어떤 두 정점 u, v가 있을 때, u이거나 u의 조상이면서 동시에 v이거나 v의 조상인 노드들 중 가장 깊은 노드를 찾는 알고리즘이야.\n",
      "level": "중급",
      "parent": null
    },
    {
      "name": "lca",
      "brief_explain": "트리상에서 어떤 두 정점 u, v가 있을 때, u이거나 u의 조상이면서 동시에 v이거나 v의 조상인 노드들 중 가장 깊은 노드를 찾는 알고리즘이야.",
      "detail_explain": "트리상에서 어떤 두 정점 u, v가 있을 때, u이거나 u의 조상이면서 동시에 v이거나 v의 조상인 노드들 중 가장 깊은 노드를 찾는 알고리즘이야.\n",
      "level": "중급",
      "parent": null
    },
    {
      "name": "재귀",
      "brief_explain": "자신을 정의할 때 자기 자신을 재참조하는 방법이야.",
      "detail_explain": "자신을 정의할 때 자기 자신을 재참조하는 방법이야.\n자신보다 더 범위가 작은 값을 참조해 하위문제를 해결하며 재귀함수 호출이 더 이상 반복되지 않는 base case를 구현해야해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "에라토스테네스의 체",
      "brief_explain": "고대 그리스의 수학자 에라토스테네스가 만들어 낸 소수를 찾는 방법",
      "detail_explain": "2부터 구하고자 하는 구간의 모든 수를 나열한 후 자기자신을 제외한 배수를 지운다. 이 과정을 반복하면 남은 수가 소수가 된다.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "해시를 사용한 집합과 맵",
      "brief_explain": "해시 자료구조를 사용해서 집합이나 맵을 구현하는 알고리즘이야.",
      "detail_explain": "해시 자료구조를 사용해서 집합이나 맵을 구현하는 알고리즘이야.\n임의의 길이의 데이터를 고정길이의 데이터로 매핑하는 함수를 통해 O(1)의 시간으로 집합과 맵을 구현하는 방식이야.\n 구현할 때 임의의 키값이 같은 값을 가르키는 해시충돌을 해결하는게 중요해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "강한 연결 요소",
      "brief_explain": "단방향 그래프에서 사이클을 찾는 알고리즘이야.",
      "detail_explain": "두번의 DFS를 활용하는 코사라주 알고리즘이 대표적으로 첫번째 DFS에서는 하나의 정점에서 도달할 수 있는 먼 곳에서 가까운 순으로 번호를 달아주고, 두번째 DFS에서 역방향 그래프를 사용해 같은 정점에 도달했는지 확인하는 방법으로 구현을해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "플로이드–와샬",
      "brief_explain": "간선의 가중치에 상관없이 그래프에서 최단 경로를 찾는 알고리즘이야.",
      "detail_explain": "O(V^3)의 시간복잡도로 모든 정점에서 모든 정점으로의 초단 경로를 구하고 거쳐가는 정점을 모두 탐색하며 최단거리를 구하는 방법으로 구현해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "고속 푸리에 변환",
      "brief_explain": "이산 푸리에 변환(DFT)과 그 역변환을 빠르게 수행하는 효율적인 알고리즘이야",
      "detail_explain": "가장 일반적으로 쿨리-튜키 알고리즘을 사용해.\n이 알고리즘은 분할 정복 알고리즘을 사용하며, 재귀적으로 n 크기의 DFT를 두 DFT로 나눈 뒤 그 결과를 O(n) 시간에 합치는 방법으로 O(NlogN)의 시간복잡도를 가져 ",
      "level": "고급",
      "parent": null
    },
    {
      "name": "위상 정렬",
      "brief_explain": "방향 그래프에 존재하는 각 정점들의 선행 순서를 위배하지 않으면서 모든 정점을 나열하는 알고리즘이야.",
      "detail_explain": "먼저 간선수가 없는 정점들을 큐에 삽입하고, 큐에서 정점을 추출해 해당 정점과 연결된 모든 정점의 간선의 수를 감소시켜.\n감소시킨 정점의 간선 수가 0이 되면 큐에 추가하는 방법으로 구현해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "볼록 껍질",
      "brief_explain": "2차원 평면상에 점이 여러 개가 있을 때 모든 점을 포함시키는 볼록 다각형을 만드는 알고리즘이야.",
      "detail_explain": "그라함 스캔 알고리즘을 사용해서 구현해\n우선 기준점을 잡고 모든 점들을 반시 계방향으로 정렬을 한 후, 각 점의 각도를 비교해가며 구현하는 방식이야.",
      "level": "고급",
      "parent": null
    },
    {
      "name": "선형대수학",
      "brief_explain": "2차원 혹은 3차원의 직교 좌표계의 벡터와 행렬을 연구하는 선형대수학적 지식을 사용해 문제를 해결하는 알고리즘이야.",
      "detail_explain": "2차원 혹은 3차원의 직교 좌표계의 벡터와 행렬을 연구하는 선형대수학적 지식을 사용해 문제를 해결하는 알고리즘이야.\n 행렬의 연산이나 벡터의 계산등의 지식을 필요로해.",
      "level": "중급",
      "parent": "수학"
    },
    {
      "name": "최단거리",
      "brief_explain": "그래프 자료구조에서 각 정점사이의 최단거리를 구하는 알고리즘이야.",
      "detail_explain": "간선에 음의 가중치가 없을 때는 다익스트라 알고리즘을 사용하고, 음의 가중치를 가질 때는 벨만포드, 전체 쌍의 최단 거리를 구할 때는 플로이드와샬 알고리즘을 주로 사용해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "완전탐색",
      "brief_explain": "문제를 해결하기 위한 모든 방법을 하나씩 대입해 보는 방식으로 해결하는 알고리즘이야",
      "detail_explain": "문제를 해결하기 위한 모든 방법을 하나씩 대입해 보는 방식으로 해결하는 알고리즘이야.\n 많은 시간이 걸리지만 모든 경우의 수를 탐색하므로 100% 답을 찾는게 가능해.",
      "level": "초급",
      "parent": null
    },
    {
      "name": "정렬",
      "brief_explain": "원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘이야.",
      "detail_explain": "단순한 정렬으로는 삽입정렬, 선택정렬, 버블정렬 등의 방법이 있고, 효율적인 정렬 방법으로는 합병정렬, 힙정렬, 퀵정렬 등의 방법이 있어.",
      "level": "초급",
      "parent": null
    },
    {
      "name": "트라이",
      "brief_explain": "우리가 여러개의 문자열을 가지고 있을 때, 어떤 문자열이 우리가 가지고 있는 문자열 중 하나인지 알아내는 알고리즘이야",
      "detail_explain": "여러 문자열들의 모든 접두사를 K진 트리에 넣어준 자료구조를 의미해. 이 자료구조를 통해 어떤 문자열이 트리에 포함되어있는지 빠르게 확인을 할 수 있어. 모든 문자만큼 노드가 생기므로 메모리를 많이 차지하지만 그만큼 어떠한 문자열이 현재 트리에 저장되어있는지 확인할 때 O(찾고자 하는 문자열의 길이)의 시간복잡도로 빠르게 수행되지.",
      "level": "중급",
      "parent": "자료 구조"
    },
    {
      "name": "포함 배제의 원리",
      "brief_explain": "유한 집합의 합집합의 원소 개수를 세는 기법이야. 주로 조합론적 문제를 해결할 떄 쓰지.",
      "detail_explain": "유한 집합의 합집합의 원소 개수를 세는 기법이야. 집합 A, B, C의 합집합의 원소의 개수는 n(A) + n(B) + n(C_ - n(A ∩ B) - n(B ∩ C) - n(A ∩ C) + n(A ∩ B ∩ C)로 구할 수 있어. 즉 겹치는 부분이 홀수면 더하고, 짝수면 빼면 돼. 여러 조합론적 문제에서 활용되는 기법이야. 시간복잡도는 O(2^(집합의 개수))이야",
      "level": "초급",
      "parent": "수학"
    },
    {
      "name": "값 / 좌표 압축",
      "brief_explain": "값이나 좌표의 범위가 너무 클때 값/좌표를 정렬해서 정렬된 인덱스로 값을 바꾸어 문제의 범위를 줄이는 방법이야.",
      "detail_explain": "값이나 좌표의 범위가 너무 클때 범위를 줄일 수 있는 기법이야. 좌표의 경우 x, y로 나누어 정렬을 한다음 각각의 값을 인덱스로 바꾸어서 다시 그 좌표에 넣어줌으로써 (-1000, 200), (1000, -20)을 (0,1), (1,0)의 형태로 압축시킬 수 있어. 범위가 줄어들기에 쿼리, 세그먼트 트리 등에 같이 응용해서 많이 사용되는 기법이지.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "볼록 껍질을 이용한 최적화",
      "brief_explain": "볼록 껍질이란 2차원 평면상에 점이 여러 개가 있을 때 이 점들 중 일부를 골라 만들 수 있는, 나머지 점들을 모두 포함하는 볼록다각형이야. 이걸 통해 수학 및 컴퓨터 과학에 광범위하게 적용하여 문제를 해결할 수 있어.",
      "detail_explain": "볼록 껍질이란 2차원 평면상에 점이 여러 개가 있을 때 이 점들 중 일부를 골라 만들 수 있는, 나머지 점들을 모두 포함하는 볼록다각형이야. 이걸 통해 점들 사이의 가장 멀리 있는 선분은 볼록 껍질 경계의 점인 것 등 다양한 성질을 광범위하게 적용하여 문제를 해결할 수 있어.",
      "level": "고급",
      "parent": "볼록 껍질"
    },
    {
      "name": "KMP",
      "brief_explain": "엄청 빠른 문자열 검색 기법이야",
      "detail_explain": "어떤 문자열 A서 부분 문자열 B가 포함되어있는지를 검색하는 알고리즘이야. 접두사와 접미사의 성질을 사용하여 중간에 일치하지않는 문자열의 중간 단계를 빠르게 건너뛰고 검색하여 시간복잡도 O(문자열 A의 길이 + 문자열 B의 길이)의 빠른 검색이 가능해.",
      "level": "중급",
      "parent": "문자열"
    },
    {
      "name": "배낭 문제",
      "brief_explain": "다이나믹 프로그래밍을 사용해서 푸는 문제야.",
      "detail_explain": "다이나믹 프로그래밍을 통해 나눌 수 없는 값들을 정해진 조건(무게)까지 만족하면서 최댓값을 얻는 문제야. 나눌 수 있는 배낭 문제일 경우 그리디를 사용하면 쉽게 풀 수 있어.",
      "level": "초급",
      "parent": "다이나믹 프로그래밍"
    },
    {
      "name": "접미사 배열과 LCP 배열",
      "brief_explain": "접미사 배열은 어떤 문자열의 시작 인덱스에 따른 접미사들을 사전순으로 정렬한 배열이고 LCP 배열은 두 접미사의 최대 공통 접두사의 길이인 LCP를 모은 배열을 의미해.",
      "detail_explain": "접미사 배열은 어떤 문자열의 시작 인덱스에 따른 접미사들을 사전순으로 정렬한 배열이고 LCP 배열은 두 접미사의 최대 공통 접두사의 길이인 LCP를 모은 배열을 의미해. 접미사 배열은 단순히 접미사를 구하고 정렬을 하면 O(N^2logN)이 걸리고 접미사 배열들을 직접 비교해서 LCP 배열을 구하면 O(N^2)이 걸리기에 각각 O(Nlog^2N), O(N)이 걸리는 방법을 구현해서 풀어야 하는 문제가 있어.",
      "level": "중급",
      "parent": "문자열"
    },
    {
      "name": "희소 배열",
      "brief_explain": "희소 배열은 배열에 속한 원소의 위치가 연속적이지 않은 배열을 말해.",
      "detail_explain": "희소 배열은 배열에 속한 원소의 위치가 연속적이지 않은 배열로 배열의 의미있는 정보보다 비어있는 정보가 더 많은 배열을 의미해. 그렇기에 의미있는 정보만 모아서 활용을 하는 기법을 쓸 수 있어. 비슷한 종류로는 희소 행렬이 있어." ,
      "level": "중급",
      "parent": "자료 구조"
    },
    {
      "name": "최소 비용 최대 유량",
      "brief_explain": "최소 비용을 구하여 그 최소 비용에 해당하는 간선으로의 최대 유량을 구하는 알고리즘이야.",
      "detail_explain": "최소 비용을 구하여 그 최소 비용에 해당하는 간선으로의 최대 유량을 구하는 알고리즘이야. 최소 비용이란 최단 거리를 구하는 문제라 볼 수 있고 최단 거리를 통해 네트워크나 그래프의 최대 지나가는 양(유량)을 구하는 알고리즘이야. 이때 비용이 음수가 될 수 있기에 음수가 포함된 최단거리를 구하는 알고리즘(벨몬포드, SPFA)을 통해 구할 수 있어.",
      "level": "중급",
      "parent": "그래프 이론"
    },
    {
      "name": "제곱근 분할법",
      "brief_explain": "특정 구간의 쿼리를 O(√N)에 처리하는 알고리즘이야.",
      "detail_explain": "구간을 √N개로 분할하여 관리하여 특정 구간의 쿼리를 O(√N)에 처리할 수 있도록 만드는 알고리즘이야. 이를 이용해 구간의 최댓값, 최솟값, 구간합 등을 구하거나 응용하여 Mo's 알고리즘의 기반이 돼.",
      "level": "고급",
      "parent": null
    },
    {
      "name": "작은 집합에서 큰 집합으로 합치는 테크닉",
      "brief_explain": "작은 집합에서 큰 집합으로 합치는 테크닉",
      "detail_explain": "작은 집합에서 큰 집합으로 합치는 테크닉",
      "level": "고급",
      "parent": null
    },
    {
      "name": "유클리드 호제법",
      "brief_explain": "두 수의 최대공약수를 구하는 알고리즘이야.",
      "detail_explain": "두 수의 최대공약수를 구하는 알고리즘이야. MOD 연산(두 값을 나눈 나머지를 구하는 연산)을 반복해서 O(log(n+m))으로 최대공약수를 구할 수 있어.",
      "level": "초급",
      "parent": "수학"
    },
    {
      "name": "덱",
      "brief_explain": "덱은 양쪽 끝 모두 원소를 넣거나 뺄 수 있는 자료구조야.",
      "detail_explain":  "덱은 양쪽 끝 모두 원소를 넣거나 뺄 수 있는 자료구조야. 앞/뒤 모두 원소를 추가/제거/확인 모두 O(1)의 시간복잡도를 가지고 있어. 스택과 큐 성질을 모두 가지고 있고 배열이나 라이브러리를 통해 구현할 수 있어.",
      "level": "초급",
      "parent":  "자료 구조"
    },
    {
      "name": "확률론",
      "brief_explain": "난수를 발생시켜 진행과정을 결정하는 알고리즘이야. 흔히 동전을 던진다고 표현하지.",
      "detail_explain":  "난수를 발생시켜 진행과정을 결정하는 알고리즘이야. 흔히 동전을 던진다고 표현하지만 실제로는 의사난수 생성기를 사용해. 알고리즘의 성능을 평균적으로 향상시키기 위해 난수를 사용하고 그렇기 때문에 알고리즘의 성능은 확률변수이며, 확률변수의 기댓값이 실제로 원하는 성능이야. 알고리즘 성능의 최악의 경우는 일어날 확률이 극히 작기 때문에 대부분 무시하게 돼.",
      "level": "고급",
      "parent":  "수학"
    },
    {
      "name": "런타임 전의 전처리",
      "brief_explain": "런타임이 실행되기전에 전처리를 통해 문제를 푸는 방법이야.",
      "detail_explain":  "런타임이 실행되기전에 필요한 데이터나 구조, 연산 등을 미리 처리를 해놓아 불필요한 시간을 아끼거나 여러가지 방법을 응용하여 푸는 방법이야.",
      "level": "중급",
      "parent":  null
    },
    {
      "name": "스프라그–그런디 정리",
      "brief_explain": "게임 이론 중 하나로 게임판의 상태를 각각 하나의 자연수 (그런디 수)로 치환할 수 있다는 것이 스프라그-그런디 정리야.",
      "detail_explain":  "게임 이론 중 하나로 게임판의 상태를 각각 하나의 자연수 (그런디 수)로 치환할 수 있다는 것이 스프라그-그런디 정리야. 이를 통해 각각의 상태에 따른 최적의 경우를 구해서 다이나믹 프로그래밍을 통해 게임 이론 문제를 풀 수 있어.",
      "level": "중급",
      "parent":  "게임 이론"
    },
    {
      "name": "매개 변수 탐색",
      "brief_explain": "최적화 문제를 결정 문제로 풀 수 있도록 하는 알고리즘이야.",
      "detail_explain":  "어떤 상황에서 최적인 값을 찾아야 할 때 조건이 만족됐다는 것을 true 조건이 만족하지 않은 것을 flase로 취급하여 결정 문제로 변환을 하고 그 중 조건을 만족하는 최댓값을 구하여 최적값을 구하는 알고리즘이야. 최적화 문제를 결정 문제처럼 바꾸어 이분 탐색을 하는 거라 생각하면 되지 그래서 O(logN)으로 풀수가 있어.",
      "level": "중급",
      "parent":  null
    },
    {
      "name": "가장 긴 증가하는 부분 수열: O(n log n)",
      "brief_explain": "가장 긴 증가하는 부분 수열을 구하는 알고리즘으로 다이나믹 프로그래밍으론 O(N^2)이지만 이진탐색을 사용하면 O(NlogN)으로 구할 수 있어.",
      "detail_explain":  "가장 긴 증가하는 부분 수열을 구하는 알고리즘으로 다이나믹 프로그래밍으론 O(N^2)이지만 i번째 원소 직전에 올 수 있는 원소들중 가장 길게 만들 수 있는 것을 찾을 때, 이진탐색을 사용해 O(NlogN)으로 구할 수 있어.",
      "level": "초급",
      "parent":  "이진 탐색"
    },
    {
      "name": "뫼비우스 반전 공식",
      "brief_explain": "g와 f가 수론적 함수이며 g(n)=∑ d∣n f(d) 이면 f(n)=∑ d∣n g(d)μ(n/d) 인 공식이야. 간단히 말하면 g(n)이 n의 모든 양의 약수 d에 대해 f(d)의 누적합으로 표현될 때, f(n)을 g(d)를 이용해서 구할 수 있는 공식이야.",
      "detail_explain": "g와 f가 수론적 함수이며 g(n)=∑ d∣n f(d) 이면 f(n)=∑ d∣n g(d)μ(n/d) 인 공식이야. 간단히 말하면 g(n)이 n의 모든 양의 약수 d에 대해 f(d)의 누적합으로 표현될 때, f(n)을 g(d)를 이용해서 구할 수 있는 공식이야.",
      "level": "고급",
      "parent": null
    },
    {
      "name": "덱을 이용한 다이나믹 프로그래밍",
      "brief_explain": "덱 자료구조를 이용해서 다이나믹 프로그래밍을 하는 방법이야.",
      "detail_explain": "먼저, 다이나믹 프로그래밍은 큰 문제를 작은 문제로 나누어 풀 때 반복되는 작은 문제들의 값을 저장해두었다가 재사용하는 방법을 말해. 이런 다이나믹 프로그래밍을 할 때 맨 처음과 맨 마지막에서 입출력을 할 수 있는 자료구조인 덱을 사용하는 방법이 덱을 이용한 다이나믹 프로그래밍이야.",
      "level": "중급",
      "parent": "다이나믹 프로그래밍"
    },
    {
      "name": "정규 표현식",
      "brief_explain": "특정한 규칙을 가진 문자열의 집합을 표현하는데 사용하는 형식 언어를 말해. 주로 문자열의 검색과 치환을 위한 용도로 사용돼.",
      "detail_explain": "정규 표현식은 일치하는 텍스트가 준수해야 하는 패턴을 표현하기 위해 특정한 표준의 텍스트 신택스를 의미하기 위해 사용돼. 일반적으로 텍스트 문자열에서 일치하는 패턴을 찾을 때 사용해.",
      "level": "초급",
      "parent": null
    },
    {
      "name": "링크/컷 트리",
      "brief_explain": "여러 개의 트리를 관리하는 자료구조로, 트리 두개를 연결하고(Link), 끊는(Cut) 연산을 가지고 있어.",
      "detail_explain": "여러 개의 트리를 관리하는 자료구조로, 이 자료구조의 특징은 find_root(노드가 속한 트리의 루트), link(한 트리의 루트를 다른 트리의 노드로 연결), cut(루트가 아닌 노드와 부모 사이의 연결 제거) 연산을 모두 O(logN)의 복잡도에 수행이 가능하다는 것이야. 또, 여러 트리 간 연결-잘라내기가 자유롭고, Splay Tree를 기반으로 한 자료구조로 다양한 쿼리를 효율적으로 처리할 수가 있다는 장점이 있어.",
      "level": "고급",
      "parent": "트리"
    },
    {
      "name": "매내처",
      "brief_explain": "회문(팰린드롬)에 대한 문제를 빠른 시간 안에 해결할 수 있는 알고리즘이야.",
      "detail_explain": "매내처 알고리즘을 적용하면 문자열의 모든 위치에 대해서 그 위치를 중심으로 하는 최대 회문(팰린드롬)의 한쪽 길이를 O(n)안에 구할 수 있어. 예를 들어 banana에 이 알고리즘을 적용하면 결과는 [0,0,1,2,1,0]이 나오지.",
      "level": "고급",
      "parent": null
    },
    {
      "name": "볼록 다각형 내부의 점 판정",
      "brief_explain": "볼록한 다각형 내부에 점이 있는지 없는지 검사하는 문제야.",
      "detail_explain": "다각형 내부에 점이 있는지 없는지 판정할 때 자주 쓰이는 방법은 The Crossing Number (cn) 교차한 횟수 방법이 있어. 이 방법은 점에서 출발한 반직선이 다각형 경계선을 몇번 교차해 가는지 세어서 짝수일 때는 외부, 홀수일 때는 내부에 존재함을 알아내.",
      "level": "고급",
      "parent": "기하학"
    },
    {
      "name": "오일러 피 함수",
      "brief_explain": "정수환의 몫환의 가역원을 세는 함수야. 즉, n이 양의 정수일 때, ϕ(n)은 n과 서로소인 1부터 n까지의 정수의 개수와 같아.",
      "detail_explain": "ϕ(n)은 n과 서로소인 1부터 n까지의 정수의 개수와 같아. 오일러 피 함수는 곱셈적 함수야. 즉, 두 정수 m,n이 서로소라면, ϕ(mn)=ϕ(m)ϕ(n) 이 성립해. 소인수분해를 한 뒤 오일러 파이 함수가 곱셈적 함수임을 이용해서 계산하면 쉽게 답을 구할 수 있어.",
      "level": "고급",
      "parent": null
    },
    {
      "name": "연결 리스트",
      "brief_explain": "각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저항하는 자료구조야.",
      "detail_explain": " 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조로, 데이터를 담고 있는 노드들이 연결되어 있는데, 노드의 포인터가 다음이나 이전의 노드와의 연결을 담당하고 있어. 연결 리스트의 종류로는 단일 연결 리스트, 이중 연결 리스트 등이 있어. 연결 리스트는 늘어선 노드의 중간지점에서도 자료의 추가와 삭제가 O(1)의 시간에 가능하다는 장점이 있지만, 배열이나 트리 구조와는 달리 특정 위치의 데이터를 검색할 때 O(n)의 시간이 걸리는 단점도 있어.",
      "level": "초급",
      "parent": null
    },
    {
      "name": "0-1 너비 우선 탐색",
      "brief_explain": "가중치가 0과 1만 있는 그래프에서 최단 거리를 구하는 방법이야.",
      "detail_explain": "큐를 이용한 너비 우선 탐색와 비슷하지만, 0-1 너비 우선 탐색은 덱을 사용하여 가중치가 0이면 덱의 앞에 넣어 빨리 처리해 버리고, 1이면 일반 너비 우선 탐색과 같이 덱의 뒤에 넣어.",
      "level": "중급",
      "parent": "그래프 탐색"
    },
    {
      "name": "수치해석",
      "brief_explain": "자연과학, 공학, 의학, 그리고 사회과학 등에 나타나는 문제들 중, 수학적인 문제로 표현될 수 있는 문제들을 궁극적으로 컴퓨터를 이용하여 해결하고자 하는 수학의 실질적인 응용분야야.",
      "detail_explain": "수치해석에서 문제를 해결하는 과정은 수학적 모형화(해결하고자 하는 문제를 역학, 생물학, 경제학 등의 기본 가설이나 법칙들을 사용하여 상 및 편미분방정식, 대수방정식 등의 수학적인 문제로 변형하는 단계) -> 수학적 분석(수학적 모형화 과정을 거쳐 생성된 수학적 문제를 미분방정식, 함수해석학, 기하학 및 대수학 등 가능한 수학의 이론들을 적용하여 해의 유일성, 존재성 및 정칙성 등을 분석하는 단계) -> 수치적 분석(좁은 의미의 수치해석이라고도 할 수 있는데, 앞의 수학적 분석에서 다루어진 문제의 해가 존재하면, 이 해를 어떻게 컴퓨터를 이용하여 구할 것인가에 대한 수치적 알고리즘을 개발하고, 이 알고리즘을 적용하여 구한 해의 수렴성 판정 및 오차분석 등을 하는 단계) -> 수치 실험(실제로 가장 효율적인 수치 알고리즘에 따라 프로그램을 작성하여 원래 문제를 해결하는 단계) 4단계로 나눌 수 있어.",
      "level": "고급",
      "parent": null
    },
    {
      "name": "외판원 순회 문제",
      "brief_explain": "도시들이 있고 특정 도시에서 도시로 이동할 때 드는 비용이 주어졌을 때, 불특정한 도시에서 출발해서 모든 도시를 돌고 다시 출발 도시로 돌아왔을 때 드는 최소 비용을 구하는 문제가 외판원 순회 문제야.",
      "detail_explain": "어떤 외판원이 n개의 도시를 방문할 계획을 수립하고 있다고 가정해 보자. 각 도시는 다른 모든 도시와 도로로 연결되어 있어. 이때 출장 비용을 최소로 줄이기 위해서 외판원이 거주하고 있는 도시에서 각 도시를 한 번씩만 방문하고 다시 출발한 도시로 돌아오는 가장 최소 비용의 일주여행 경로를 찾는것이 외판원 순회 문제야.",
      "level": "중급",
      "parent": "다이나믹 프로그래밍"
    },
    {
      "name": "인터프리터",
      "brief_explain": "코드를 한 줄씩 읽어 내려가며 실행하는 프로그램을 말해.",
      "detail_explain": "급 언어로 작성된 프로그램 전체를 목적 프로그램으로 번역하는 컴파일러와 달리, 인터프리터는 고급 언어로 작성된 프로그램을 한 줄 단위로 받아들여 번역하고, 번역과 동시에 프로그램을 한 줄 단위로 즉시 실행시키는 프로그램이야. 컴파일러와 비교해 실행속도는 느리지만 번역속도는 빠르다는 장점이 있어.",
      "level": "초급",
      "parent": null
    },
    {
      "name": "폴라드 로",
      "brief_explain": "존 폴라드가 1975년에 고안한 소인수분해 알고리즘이야. 저장 공간을 적게 사용하고 소인수분해하는 데 걸리는 실행 시간은 소인수분해하려는 합성수의 가장 작은 소인수의 제곱근에 비례하는 특징이 있어.",
      "detail_explain": null,
      "level": "고급",
      "parent": null
    },
    {
      "name": "Alien 트릭",
      "brief_explain": "IOI 2016 이후에 알려지기 시작했는데 아직까지도 많이 알려지지는 않은 알고리즘이라서 나도 아직 공부중이야.",
      "detail_explain": null,
      "level": "고급",
      "parent": null
    },
    {
      "name": "함수 개형을 이용한 최적화",
      "brief_explain": "DP 식을 그래프 형태로 나타냈을 때의 개형을 바탕으로 하는 최적화야.",
      "detail_explain": "입력의 크기가 굉장히 커지는 경우에도, 주어진 DP 점화식이 가지는 그래프 개형을 이용한 독특한 최적화를 통해 문제를 O(NlogN)에 해결할 수 있다는 특징이 있다.",
      "level": "고급",
      "parent": null
    },
    {
      "name": "모듈로 곱셈 역원",
      "brief_explain": "Ax ≡ 1 mod N 인 식을 만족하는 x를 A의 N에 대한 모듈로 역원이라고 해. 일반적으로 A^-1라고 표기해.",
      "detail_explain": "(A * A^-1) ≡ 1 (mod N) 또는 (A * A^-1) mod N = 1 에서 A^-1가 모듈로 곱셈 역원이야. 이 수를 구하는 방법은 먼저 0에서 N-1까지의 A^-1값에 대해 A * A^-1 mod C 를 계산하고, A * A^-1 mod N = 1을 만족하는 A^-1값을 찾으면 돼.",
      "level": "중급",
      "parent": "수학"
    },
    {
      "name": "다각형의 넓이",
      "brief_explain": "다각형의 꼭짓점이 순서대로 주어졌을 때, 외적공식을 이용하여 다각형의 꼭짓점만으로 다각형의 면적을 구하는 문제야.",
      "detail_explain": null,
      "level": "고급",
      "parent": null
    },
    {
      "name": "기댓값의 선형성",
      "brief_explain": "기댓값은 선형성이라는 성질을 갖고 있다는 특징으로 문제를 푸는 방법이야.",
      "detail_explain": "함수 f에 대해 임의의 수 x,y에 대해 f(x+y) = f(x) + f(y) 가 항상 성립하고, 임의의 수 x와 a에 대해 f(ax)=af(x) 가 항상 성립할 때 함수 f는 선형이라고 할 수 있어. 기댓값도 E[aX+bY] = aE[X]+bE[y] 이므로 선형이야.",
      "level": "고급",
      "parent": null
    },
    {
      "name": "오프라인 동적 연결성 판정",
      "brief_explain": "아직 잘 모르겠어..",
      "detail_explain": null,
      "level": "고급",
      "parent": null
    },
    {
      "name": "선형 계획법",
      "brief_explain": "최적화 문제의 일종으로 주어진 선형 조건들을 만족시키면서 선형인 목적 함수를 최적화하는 문제야.",
      "detail_explain": "한정된 자원을 효율적으로 할당하여 목적함수를 최대화하거나 최소화하는 문제를 다룰때 사용해. 선형 계획법으로 문제를 푸는 방법은 주어진 선형 조건을 부등식으로 나타내고, 제약조건을 그래프로 표현한 다음, 가능한 영역에서 최적의 해를 찾으면 돼.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "번사이드 보조정리",
      "brief_explain": "원순열 등의 경우의 수를 구하는 문제에서 자주 나오는 정리야.",
      "detail_explain": null,
      "level": "고급",
      "parent": null
    },
    {
      "name": "오목 다각형 내부의 점 판정",
      "brief_explain": "오목한 다각형 내부에 점이 있는지 없는지 검사하는 문제야.",
      "detail_explain": "다각형 내부에 점이 있는지 없는지 판정할 때 자주 쓰이는 방법은 The Crossing Number (cn) 교차한 횟수 방법이 있어. 이 방법은 점에서 출발한 반직선이 다각형 경계선을 몇번 교차해 가는지 세어서 짝수일 때는 외부, 홀수일 때는 내부에 존재함을 알아내.",
      "level": "고급",
      "parent": "기하학"
    },
    {
      "name": "피타고라스 정리",
      "brief_explain": "직각 삼각형의 빗변의 제곱이 두 직각변의 제곱의 합과 같다는 정리야.",
      "detail_explain": "직각 삼각형의 빗변의 제곱이 두 직각변의 제곱의 합과 같다는 정리야. c가 빗변인 abc 직각삼각형에서 a^2 + b^2 = c^2 이야.",
      "level": "초급",
      "parent": "수학"
    },
    {
      "name": "키타마사",
      "brief_explain": "아직 잘 모르겠어..",
      "detail_explain": null,
      "level": "고급",
      "parent": null
    },
    {
      "name": "트리 동형 사상",
      "brief_explain": "인접성이 같을 때(노드 사이의 같은 매핑 구조를 가질 때) 두 그래프는 동형 사상을 가진다고 해. 즉, 두 트리의 간선의 방향만 조절해 완전히 동일한 트리가 되면 두 트리는 동형이야.",
      "detail_explain": null,
      "level": "고급",
      "parent": "트리"
    },
    {
      "name": "홀의 결혼 정리",
      "brief_explain": "어떤 경우에 남녀 사이에 짝을 지어 주는 게 가능한가에 대한 정리야. 홀의 결혼 정리 조건을 만족하면 모든 남녀가 결혼할 수 있어.",
      "detail_explain": "어떤 그래프 G = (L∪R,E) 가 주어졌다고 하자. 어떤 부분집합 S⊆L 에 대해서, S에 인접한 정점들의 집합을 N(S)⊆R 라고 할 때, L의 모든 정점이 참여하는 matching이 존재하는 필요충분조건은 모든 L의 부분집합 S가 |S|≤|N(S)|를 만족하는 것이 바로 홀의 결혼 정리야.",
      "level": "중급",
      "parent": "그래프 탐색"
    },
    {
      "name": "헝가리안",
      "brief_explain": "가중치가 있는 이분 그래프에서 최대 가중치를 가진 간선을 찾기 위한 알고리즘이야.",
      "detail_explain": "다른 알고리즘으로 O(V^4)에 걸리는 일을 O(V^3)에. 처리할 수 있어.",
      "level": "고급",
      "parent": "그래프 탐색"
    },
    {
      "name": "이산 로그",
      "brief_explain": "a^x=b 를 만족하는 x를 가리켜.",
      "detail_explain": null,
      "level": "고급",
      "parent": null
    },
    {
      "name": "최소 외접원",
      "brief_explain": "모든 점을 포함하는 가장 작은 원을 찾는 문제야.",
      "detail_explain": "",
      "level": "중급",
      "parent": "기하학"
    },
    {
      "name": "중간에서 만나기",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  null
    },
    {
      "name": "Heavy-light 분할",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  null
    },
    {
      "name": "선분 교차 판정",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  ["수학", "기하학"]
    },
    {
      "name": "센트로이드 분할",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  ["그래프 이론", "트리"]
    },
    {
      "name": "슬라이딩 윈도우",
      "brief_explain": "",
      "detail_explain": "",
      "level": "초급",
      "parent":  null
    },
    {
      "name": "무작위화",
      "brief_explain": "",
      "detail_explain": "",
      "level": "고급",
      "parent":  null
    },
    {
      "name": "오일러 경로 테크닉",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  ["그래프 이론"]
    },
    {
      "name": "2-SAT",
      "brief_explain": "",
      "detail_explain": "",
      "level": "고급",
      "parent":  "그래프 이론"
    },
    {
      "name": "삼분 탐색",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  "분할 정복"
    },
    {
      "name": "미적분학",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  "수학"
    },
    {
      "name": "최대 유량 최소 컷 정리",
      "brief_explain": "",
      "detail_explain": "",
      "level": "고급",
      "parent":  "그래프 이론"
    },
    {
      "name": "가우스 소거법",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  null
    },
    {
      "name": "휴리스틱",
      "brief_explain": "",
      "detail_explain": "",
      "level": "고급",
      "parent":  null
    },
    {
      "name": "단절점과 단절선",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  null
    },
    {
      "name": "퍼시스턴트 세그먼트 트리",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  "세그먼트 트리"
    },
    {
      "name": "3차원 기하학",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  "기하학"
    },
    {
      "name": "오일러 경로",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  "그래프 이론"
    },
    {
      "name": "선인장",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  null
    },
    {
      "name": "비트 집합",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  null
    },
    {
      "name": "중국인의 나머지 정리",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  "수학"
    },
    {
      "name": "분할 정복을 사용한 최적화",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  "분할 정복"
    },
    {
      "name": "큐",
      "brief_explain": "",
      "detail_explain": "",
      "level": "초급",
      "parent":  "자료 구조"
    },
    {
      "name": "Mo's",
      "brief_explain": "",
      "detail_explain": "",
      "level": "고급",
      "parent":  null
    },
    {
      "name": "벨만–포드",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  "최단 거리"
    },
    {
      "name": "병렬 이분 탐색",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  "이분 탐색"
    },
    {
      "name": "벌래캠프–매시",
      "brief_explain": "",
      "detail_explain": "",
      "level": "고급",
      "parent":  null
    },
    {
      "name": "오일러 지표 (χ=V-E+F)",
      "brief_explain": "",
      "detail_explain": "",
      "level": "고급",
      "parent":  null
    },
    {
      "name": "다차원 세그먼트 트리",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "평면 그래프",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  "그래프 이론"
    },
    {
      "name": "아호-코라식",
      "brief_explain": "",
      "detail_explain": "",
      "level": "고급",
      "parent":  "문자열"
    },
    {
      "name": "스플레이 트리",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "순열 사이클 분할",
      "brief_explain": "",
      "detail_explain": "",
      "level": "고급",
      "parent":  null
    },
    {
      "name": "페르마의 소정리",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  "수학"
    },
    {
      "name": "라빈–카프",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  "해싱"
    },
    {
      "name": "확장 유클리드 호제법",
      "brief_explain": "",
      "detail_explain": "",
      "level": "고급",
      "parent": null
    },
    {
      "name": "회전하는 캘리퍼스",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  null
    },
    {
      "name": "커넥션 프로파일을 이용한 다이나믹 프로그래밍",
      "brief_explain": "",
      "detail_explain": "",
      "level": "고급",
      "parent":  "다이나믹 프로그래밍"
    },
    {
      "name": "물리학",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  null
    },
    {
      "name": "이중 연결 요소",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent":  null
    },
    {
      "name": "머지 소트 트리",
      "brief_explain": "",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    }
  ]
}