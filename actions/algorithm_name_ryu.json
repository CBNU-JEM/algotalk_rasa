
{
  "algorithm": [
    {
      "name": "수학",
      "brief_explain": "기본 수학적 지식을 사용해 문제를 해결하는 알고리즘이야",
      "detail_explain": "기본 수학적 지식을 사용해 문제를 해결하는 알고리즘이야.\n종류로는 기하학, 정수론, 조합론, 사칙연산 등이 있어.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "다이나믹 프로그래밍",
      "brief_explain": "복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법이야 ",
      "detail_explain": "문제를 여러 개의 하위 문제로 나누어 푼 다움, 문제의 정답을 한 번만 계산하고 저장한 뒤, 그것을 결합하여 최종적인 정답에 도달하는 방법이야\n최단경로 문제, 행렬의 제곱 문제 등의 최적화에 사용",
      "level": "중급",
      "parent": null
    },
    {
      "name": "구현",
      "brief_explain": "풀이 과정은 생각해내기 상대적으로 쉬우나, 이를 코드로 구현함에 있어서 여러가지 장애물이 존재하는 알고리즘이야",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "그래프 이론",
      "brief_explain": "객체 간에 짝을 이루는 관계를 모델링하기 위해 사용되는 수학 구조인 그래프를 사용하는 알고리즘이야",
      "detail_explain": "그래프는 꼭짓점(vertex), 교점(node), 점(point)으로 구성되며 이것들은 간선(edge), 즉 선으로 연결되어있어.\n간선들이 방향성을 가지면 방향 그래프, 방향성이 없으면 무 방향 그래프로 나뉘어.",
      "level": "중급",
      "parent": "자료 구조"
    },
    {
      "name": "자료 구조",
      "brief_explain": "효율적인 접근 및 수정을 위해 데이터를 구조적으로 표현하는 방식과 이를 구현하는 데 필요한 알고리즘이야 ",
      "detail_explain": "효율적인 접근 및 수정을 위해 데이터를 구조적으로 표현하는 방식과 이를 구현하는 데 필요한 알고리즘이야.\n자료구조의 대표적 예시로는 배열, 연결리스트, 스택, 큐, 그래프, 트리 등이 있어.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "문자열",
      "brief_explain": "문자열을 이용해 문제를 해결하는 알고리즘이야.",
      "detail_explain": "문자열을 이용해 문제를 해결하는 알고리즘이야.\n문자열 알고리즘의 대표적 예시로는 Naive String Search 알고리즘, Finite-state automaton based search 알고리즘, KMP 알고리즘, Rabin-Karp 알고리즘 등이 있어.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "그리디 알고리즘",
      "brief_explain": "미래를 생각하지 않고 각 단계에서 가장 최선의 선택을 하는 기법이야.",
      "detail_explain": "최적해를 구하는 데에 사용되는 근사적인 방법으로, 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 방법이야.\n그리디 알고리즘은 계산속도는 빠르지만 모든 경우에 대해서 최적해를 보장하지는 않아.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "그래프 탐색",
      "brief_explain": "자료구조인 그래프를 탐색하는 알고리즘이야.",
      "detail_explain": "자료구조인 그래프를 탐색하는 알고리즘이야.\n대표적인 방법으로 DFS(Depth First Search)와 BFS(Beside Fisrt Search) 알고리즘으로 나뉘어.",
      "level": "초급",
      "parent": "그래프 이론"
    },
    {
      "name": "브루트포스 알고리즘",
      "brief_explain": "문제를 해결하기 위한 모든 방법을 하나씩 대입해 보는 방식으로 해결하는 알고리즘이야",
      "detail_explain": "문제를 해결하기 위한 모든 방법을 하나씩 대입해 보는 방식으로 해결하는 알고리즘이야.\n 많은 시간이 걸리지만 모든 경우의 수를 탐색하므로 100% 답을 찾는게 가능해.",
      "level": "초급",
      "parent": null
    },
    {
      "name": "세그먼트 트리",
      "brief_explain": "저장된 자료를 적절히 구간별로 전처리해 그들에 대한 질의들을 빠르게 대답할 수 있도록 해주는 트리야.",
      "detail_explain": "저장된 자료를 적절히 구간별로 전처리해 그들에 대한 질의들을 빠르게 대답할 수 있도록 해주는 트리야.\n특정 구간에 대한 정보가 필요한 경우 빠른시간에 정보를 구할 수 있어. 트리를 만드는데 O(NlogN), 정보를 구하는데 O(logN)의 시간이 걸려.",
      "level": "고급",
      "parent": "트리"
    },
    {
      "name": "트리",
      "brief_explain": "그래프 자료구조의 한 종류로 각 노드들이 서로 다른 자식을 갖는 구조야.",
      "detail_explain": "그래프 자료구조의 한 종류로 각 노드들이 서로 다른 자식을 갖는 구조야.\n트리에서 최상위 노드를 루트 노드라고 불러. 노드 A가 노드 B를 가리킬 때 A를 B의 부모 노드, B를 A의 자식 노드라고 해. 자식 노드가 없는 노드를 잎 노드라고 하고, 잎 노드가 아닌 노드를 내부 노드라고 해.\n트리의 종류로는 이진 트리, B 트리, 포레스트, 트라이 등이 있어",
      "level": "중급",
      "parent": null
    },
    {
      "name": "이분 탐색",
      "brief_explain": "오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘이야.",
      "detail_explain": "오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘이야.\n처음 중간의 값을 임의의 값으로 선택하여, 그 값과 찾고자 하는 값의 크고 작음을 비교하는 방식이야. 처음 선택한 중앙값이 만약 찾는 값보다 크면 그 값은 새로운 최댓값이 되며, 작으면 그 값은 새로운 최솟값이 돼. 검색 원리상 정렬된 리스트에만 사용할 수 있다는 단점이 있지만, 검색이 반복될 때마다 목표값을 찾을 확률은 두 배가 되므로 속도가 빨라.\n시간복잡도는 O(logN)이야.",
      "level": "초급",
      "parent": null
    },
    {
      "name": "기하학",
      "brief_explain": "공간에 있는 도형의 성질, 대상들의 치수, 모양, 상대적 위치를 이용하는 알고리즘이야.",
      "detail_explain": "공간에 있는 도형의 성질, 대상들의 치수, 모양, 상대적 위치를 이용하는 알고리즘이야.\n기하학의 예시로는 선분교차, 직각 삼각형, 내접 다각형, 순황 외판원, CAD, 최소 신장 트리 등이 있어.",
      "level": "중급",
      "parent": "수학"
    },
    {
      "name": "정수론",
      "brief_explain": "각종 수의 성질을 이용하는 알고리즘이야.",
      "detail_explain": "각종 수의 성질을 이용하는 알고리즘이야.\n정수론의 예시로는 최대공약수, 최소공배수, 에라토스테네스의 체, 거듭제곱의 연산 등이 있어.",
      "level": "중급",
      "parent": "수학"
    },
    {
      "name": "너비 우선 탐색",
      "brief_explain": "시작 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법이야.",
      "detail_explain": "시작 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법이야.\n출발노드에서 목표노드까지의 최단 길이 경로를 보장하지만 경로가 매우 길 경우에는 탐색 가지가 급격히 증가함에 따라 보다 많은 기억 공간을 필요로 해.\n시간복잡도는 인접 리스트를 사용하면 O(longV+E), 인접 행렬을 사용하면 O(logV^2)이야(V=정점의 수,E=간선의 수)",
      "level": "초급",
      "parent": "그래프 탐색"
    },
    {
      "name": "조합론",
      "brief_explain": "경우의 수를 이용하는 알고리즘이야.",
      "detail_explain": "경우의 수를 이용하는 알고리즘이야.\n순열과 조합,경우의 수가 조합론에 속해.",
      "level": "중급",
      "parent": "수학"
    },
    {
      "name": "사칙연산",
      "brief_explain": " 산수의 기본이 되는 덧셈, 뺄셈, 곱셈, 나눗셈의 4가지 연산을 이용하는 알고리즘이야.",
      "detail_explain": "",
      "level": "초급",
      "parent": "수학"
    },
    {
      "name": "누적 합",
      "brief_explain": "구간의 누적합을 계산해 문제를 해결하는 알고리즘이야.",
      "detail_explain": "구간의 누적합을 계산해 문제를 해결하는 알고리즘이야.\n배열을 부분 합을 빠르게 구해야 하는 경우 시간복잡도 O(N)으로 구할 수 있어.",
      "level": "초급",
      "parent": null
    },
    {
      "name": "깊이 우선 탐색",
      "brief_explain": "탐색하다가 특정 정점에서 최대한 깊숙히 들어가서 확인한 뒤 다시 돌아가 다른 루트로 탐색하는 방법이야.",
      "detail_explain": "탐색하다가 특정 정점에서 최대한 깊숙히 들어가서 확인한 뒤 다시 돌아가 다른 루트로 탐색하는 방법이야\n단지 현 경로상의 노드들만을 기억하면 되므로 저장공간의 수요가 비교적 적고, 목표노드가 깊은 단계에 있을 경우 해를 빨리 구할 수 있지만 최단경로를 보장하지 않는다.\n시간복잡도는 인접 리스트를 사용하면 O(longV+E), 인접 행렬을 사용하면 O(logV^2)이야(V=정점의 수,E=간선의 수)",
      "level": "초급",
      "parent": "그래프 탐색"
    },
    {
      "name": "시뮬레이션",
      "brief_explain": "일련의 명령에 따라서 개체를 차례대로 이동시키는 방법으로 해결하는 알고리즘이야.",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "다익스트라",
      "brief_explain": "그래프에서 꼭짓점 간의 최단 경로를 찾는 알고리즘이야.",
      "detail_explain": "하나의 노드로부터 최단경로를 구하는 알고리즘으로 그래프 방향의 유무는 상관 없으나, 간선들 중 단 하나라도 가중치가 음수이면 이 알고리즘은 사용할 수 없어.\n출발점에서 최단거리를 저장할 배열을 만들고 출발점은 0, 다른 점에는 매우 큰 값으로 채운다음, 현재 점으로 출발점을 선택해.\n현재 점에서 갈 수 있는 길이를 비교해 작으면 갱신시키는 방법으로 구현할 수 있어. \n시간 복잡도는 우선순위 큐를 사용하면 O(ElogV), 사용하지 않으면 O(V^2 + E)야. (V=정점의 수,E=간선의 수)",
      "level": "중급",
      "parent": null
    },
    {
      "name": "비트마스킹",
      "brief_explain": "0 과 1로 이루어진 bit를 이용해 문제를 해결하는 알고리즘이야.",
      "detail_explain": "0 과 1로 이루어진 bit를 이용해 문제를 해결하는 알고리즘이야.\nbit 의 AND, OR, NOT, XOR, SHIFT 연산 등을 사용하여 문제를 해결해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "분리 집합",
      "brief_explain": "교집합이 존재하지 않는 둘 이상의 데이터 집합을 다루는 알고리즘이야.",
      "detail_explain": "교집합이 존재하지 않는 둘 이상의 데이터 집합을 다루는 알고리즘이야.\n자식노드가 부모 노드를 가르키는 형태이며 트리를 사용해 구현해.\n시간복잡도는 만드는데 O(logN), 찾는데 O(logN)이야.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "분할 정복",
      "brief_explain": "해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법이야.",
      "detail_explain": "해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법이야.\n재귀 함수나 반복문을 통해 구현가능하며 퀵소트, 머지소트, 고속 푸리에 변환등에 사용해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "애드 혹",
      "brief_explain": "해당 문제를 풀기 위해 잘 알려진 정교한 알고리즘을 적용하지 않고 해결할 수 있는 유형의 문제야.",
      "detail_explain": "해당 문제를 풀기 위해 잘 알려진 정교한 알고리즘을 적용하지 않고 해결할 수 있는 유형의 문제야.\n단순히 지시를 따르면 되는 구현 유형이나 그리디 유형 알고리즘 혹은 수학 유형으로 분류해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "구성적",
      "brief_explain": " 답을 증명할 수 있는 실제 예시를 구성하는 알고리즘이야.",
      "detail_explain": "",
      "level": "고급",
      "parent": null
    },
    {
      "name": "백트래킹",
      "brief_explain": "해를 찾아가는 도중, 지금의 경로가 해가 될 것 같지 않으면 그 경로를 더이상 가지 않고 되돌아가는 방법이야.",
      "detail_explain": "해를 찾아가는 도중, 지금의 경로가 해가 될 것 같지 않으면 그 경로를 더이상 가지 않고 되돌아가는 방법이야.\n모든 경우의 수를 탐색하는 과정에서, 조건문 등을 걸어 답이 절대로 될 수 없는 상황을 정의하고, 그러한 상황일 경우에는 탐색을 중지시킨 뒤 그 이전으로 돌아가서 다시 다른 경우를 탐색하게끔 구현해.",
      "level": "초급",
      "parent": null
    },
    {
      "name": "스위핑",
      "brief_explain": "단어의 뜻 그대로 휩쓸고 지나가며 문제를 해결하는 방식으로, 특정 기준에 따라 정렬한 후 순서대로 처리하는 알고리즘이야.",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "Case work",
      "brief_explain": "??",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "스택",
      "brief_explain": "언제나 목록의 끝에서만 제한적으로 접근할 수 있는 자료구조야.",
      "detail_explain": "언제나 목록의 끝에서만 제한적으로 접근할 수 있는 자료구조야.\n스택의 가장 윗 데이터 자리 위에 데이터를 생성하는 PUSH 연산과 가장 윗 데이터를 삭제하는 POP연산이 있어.\n맨 위에 데이터만 접근하므로 시간복잡도는 O(1)이야.",
      "level": "초급",
      "parent": null
    },
    {
      "name": "우선순위 큐",
      "brief_explain": "각 원소들이 우선순위를 갖고 있는 큐, 높은 우선순위를 가진 원소는 낮은 우선순위를 가진 원소보다 먼저 처리된는 큐야.",
      "detail_explain": "각 원소들이 우선순위를 갖고 있는 큐, 높은 우선순위를 가진 원소는 낮은 우선순위를 가진 원소보다 먼저 처리된는 큐야.\n시간복잡도는 O(logn)이야",
      "level": "중급",
      "parent": null
    },
    {
      "name": "트리에서의 다이나믹 프로그래밍",
      "brief_explain": "??",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "최대 유량",
      "brief_explain": "네트워크 흐름에서 유량을 최대화 하는 알고리즘이야.",
      "detail_explain": "네트워크 흐름에서 유량을 최대화 하는 알고리즘이야.\n대표적인 알고리즘으로 Ford–Fulkerson 알고리즘과 Edmonds-Karp 알고리즘이 있어.",
      "level": "고급",
      "parent": null
    },
    {
      "name": "파싱",
      "brief_explain": "입력 문장의 구조를 분석하여 해결하는 알고리즘이야.",
      "detail_explain": "입력 문장의 구조를 분석하여 해결하는 알고리즘이야.\n대표적인 파싱 알고리즘으로 CYK 알고리즘,LALR, LL파서, 재귀 하향 파서 등이 있다.",
      "level": "고급",
      "parent": null
    },
    {
      "name": "느리게 갱신되는 세그먼트 트리",
      "brief_explain": "??",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "투 포인터",
      "brief_explain": "1차원 배열에서 두 개의 포인터를 조작하여 원하는 결과를 얻는 알고리즘이야.",
      "detail_explain": "1차원 배열에서 두 개의 포인터를 조작하여 원하는 결과를 얻는 알고리즘이야.\n시작점 L 과 R 두개를 선언하고 R를 한칸씩 이동시키면서 답을 찾으면 L를 한칸 이동시는 방식으로 구현해.\n시간복잡도는 O(n)이야.",
      "level": "초급",
      "parent": null
    },
    {
      "name": "비트필드를 이용한 다이나믹 프로그래밍",
      "brief_explain": "??",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "트리를 사용한 집합과 맵",
      "brief_explain": "??",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "소수 판정",
      "brief_explain": "어떤 자연수 N이 소수인지 합성수인지를 판별하는 알고리즘이야.",
      "detail_explain": "어떤 자연수 N이 소수인지 합성수인지를 판별하는 알고리즘이야.\n대표적인 알고리즘으로 윌슨의 정리, 페르마 소수판별법 등이 있다.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "오프라인 쿼리",
      "brief_explain": "쿼리를 받아서 매번 처리하려다 보면 어떤 수를 써도 빠르게 다 대처할 수가 없을 때, 오프라인으로 쿼리는 처리하는 방법이야.",
      "detail_explain": "쿼리를 받아서 매번 처리하려다 보면 어떤 수를 써도 빠르게 다 대처할 수가 없을 때, 오프라인으로 쿼리는 처리하는 방법이야.\n쿼리를 바로바로 처리하지 않고 쿼리를 재배열해서 풀거나 미리 쿼리를 보고 전처리해서 푸는 유형이 있어.",
      "level": "고급",
      "parent": null
    },
    {
      "name": "게임 이론",
      "brief_explain": "??",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "분할 정복을 이용한 거듭제곱",
      "brief_explain": "??",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "이분 매칭",
      "brief_explain": "이분 그래프에서 A 그룹의 정점에서 B 그룹의 정점으로 간선을 연결 할 때,A그래프의 하나의 정점이 B그래프 하나의 정점만 가지도록 하는 알고리즘이야.",
      "detail_explain": "이분 그래프에서 A 그룹의 정점에서 B 그룹의 정점으로 간선을 연결 할 때,A그래프의 하나의 정점이 B그래프 하나의 정점만 가지도록 하는 알고리즘이야.\n dfs를 이용해서 이분 매칭을 해결할 수 있어. 이 경우 시간복잡도는 O(V*E)야 (V=정점,E=간선)",
      "level": "중급",
      "parent": null
    },
    {
      "name": "임의 정밀도 / 큰 수 연산",
      "brief_explain": "??",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "최소 스패닝 트리",
      "brief_explain": "가장 적은 간선을 갖는 그래프 내의 모든 정점을 포함하는 트리야.",
      "detail_explain": "가장 적은 간선을 갖는 그래프 내의 모든 정점을 포함하는 트리야.\nDFS, BFS을 이용하여 탐색 도중에 사용된 간선만 모으면 그래프에서 스패닝 트리를 찾을 수 있어.\n스패닝 트리는 트리의 특수한 형태이므로 모든 정점들이 연결 되어 있어야 하고 사이클을 포함하지 않아. 따라서 스패닝 트리는 그래프에 있는 n개의 정점을 정확히 (n-1)개의 간선으로 연결 해야해.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "해싱",
      "brief_explain": "임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 알고리즘이야",
      "detail_explain": "임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 알고리즘이야\n매핑전 원래 데이터 값을 키, 매핑후 데이터 값을 해시값 이라고 해.\n적은 리소스로 많은 데이터를 효율적으로 관리 할 수 있지만, 여러 키가 해시값이 같은 해시 충돌이 발생 할 수 있어.\n시간복잡도는 O(1)이야.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "최소 공통 조상",
      "brief_explain": "트리상에서 어떤 두 정점 u, v가 있을 때, u이거나 u의 조상이면서 동시에 v이거나 v의 조상인 노드들 중 가장 깊은 노드를 찾는 알고리즘이야.",
      "detail_explain": "트리상에서 어떤 두 정점 u, v가 있을 때, u이거나 u의 조상이면서 동시에 v이거나 v의 조상인 노드들 중 가장 깊은 노드를 찾는 알고리즘이야.\n",
      "level": "중급",
      "parent": null
    },
    {
      "name": "재귀",
      "brief_explain": " 자신을 정의할 때 자기 자신을 재참조하는 방법",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "에라토스테네스의 체",
      "brief_explain": "고대 그리스의 수학자 에라토스테네스가 만들어 낸 소수를 찾는 방법",
      "detail_explain": "2부터 구하고자 하는 구간의 모든 수를 나열한 후 자기자신을 제외한 배수를 지운다. 이 과정을 반복하면 남은 수가 소수가 된다.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "해시를 사용한 집합과 맵",
      "brief_explain": "??",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "강한 연결 요소",
      "brief_explain": "기본 수학적 지식을 사용해 문제를 해결하는 알고리즘",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "플로이드–와샬",
      "brief_explain": "기본 수학적 지식을 사용해 문제를 해결하는 알고리즘",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "고속 푸리에 변환",
      "brief_explain": "기본 수학적 지식을 사용해 문제를 해결하는 알고리즘",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "위상 정렬",
      "brief_explain": "기본 수학적 지식을 사용해 문제를 해결하는 알고리즘",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "볼록 껍질",
      "brief_explain": "기본 수학적 지식을 사용해 문제를 해결하는 알고리즘",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "선형대수학",
      "brief_explain": "기본 수학적 지식을 사용해 문제를 해결하는 알고리즘",
      "detail_explain": "",
      "level": "중급",
      "parent": null
    },
    {
      "name": "트라이",
      "brief_explain": "우리가 여러개의 문자열을 가지고 있을 때, 어떤 문자열이 우리가 가지고 있는 문자열 중 하나인지 알아내는 알고리즘이야",
      "detail_explain": "여러 문자열들의 모든 접두사를 K진 트리에 넣어준 자료구조를 의미해. 이 자료구조를 통해 어떤 문자열이 트리에 포함되어있는지 빠르게 확인을 할 수 있어. 모든 문자만큼 노드가 생기므로 메모리를 많이 차지하지만 그만큼 어떠한 문자열이 현재 트리에 저장되어있는지 확인할 때 O(찾고자 하는 문자열의 길이)의 시간복잡도로 빠르게 수행되지.",
      "level": "중급",
      "parent": "자료 구조"
    },
    {
      "name": "포함 배제의 원리",
      "brief_explain": "유한 집합의 합집합의 원소 개수를 세는 기법이야. 주로 조합론적 문제를 해결할 떄 쓰지.",
      "detail_explain": "유한 집합의 합집합의 원소 개수를 세는 기법이야. 집합 A, B, C의 합집합의 원소의 개수는 n(A) + n(B) + n(C_ - n(A ∩ B) - n(B ∩ C) - n(A ∩ C) + n(A ∩ B ∩ C)로 구할 수 있어. 즉 겹치는 부분이 홀수면 더하고, 짝수면 빼면 돼. 여러 조합론적 문제에서 활용되는 기법이야. 시간복잡도는 O(2^(집합의 개수))이야",
      "level": "초급",
      "parent": "수학"
    },
    {
      "name": "값 / 좌표 압축",
      "brief_explain": "값이나 좌표의 범위가 너무 클때 값/좌표를 정렬해서 정렬된 인덱스로 값을 바꾸어 문제의 범위를 줄이는 방법이야.",
      "detail_explain": "값이나 좌표의 범위가 너무 클때 범위를 줄일 수 있는 기법이야. 좌표의 경우 x, y로 나누어 정렬을 한다음 각각의 값을 인덱스로 바꾸어서 다시 그 좌표에 넣어줌으로써 (-1000, 200), (1000, -20)을 (0,1), (1,0)의 형태로 압축시킬 수 있어. 범위가 줄어들기에 쿼리, 세그먼트 트리 등에 같이 응용해서 많이 사용되는 기법이지.",
      "level": "중급",
      "parent": null
    },
    {
      "name": "볼록 껍질을 이용한 최적화",
      "brief_explain": "볼록 껍질이란 2차원 평면상에 점이 여러 개가 있을 때 이 점들 중 일부를 골라 만들 수 있는, 나머지 점들을 모두 포함하는 볼록다각형이야. 이걸 통해 수학 및 컴퓨터 과학에 광범위하게 적용하여 문제를 해결할 수 있어.",
      "detail_explain": "볼록 껍질이란 2차원 평면상에 점이 여러 개가 있을 때 이 점들 중 일부를 골라 만들 수 있는, 나머지 점들을 모두 포함하는 볼록다각형이야. 이걸 통해 점들 사이의 가장 멀리 있는 선분은 볼록 껍질 경계의 점인 것 등 다양한 성질을 광범위하게 적용하여 문제를 해결할 수 있어.",
      "level": "고급",
      "parent": "볼록 껍질"
    },
    {
      "name": "KMP",
      "brief_explain": "엄청 빠른 문자열 검색 기법이야",
      "detail_explain": "어떤 문자열 A서 부분 문자열 B가 포함되어있는지를 검색하는 알고리즘이야. 접두사와 접미사의 성질을 사용하여 중간에 일치하지않는 문자열의 중간 단계를 빠르게 건너뛰고 검색하여 시간복잡도 O(문자열 A의 길이 + 문자열 B의 길이)의 빠른 검색이 가능해.",
      "level": "중급",
      "parent": "문자열"
    },
    {
      "name": "배낭 문제",
      "brief_explain": "다이나믹 프로그래밍을 사용해서 푸는 문제야.",
      "detail_explain": "다이나믹 프로그래밍을 통해 나눌 수 없는 값들을 정해진 조건(무게)까지 만족하면서 최댓값을 얻는 문제야. 나눌 수 있는 배낭 문제일 경우 그리디를 사용하면 쉽게 풀 수 있어.",
      "level": "초급",
      "parent": "다이나믹 프로그래밍"
    },
    {
      "name": "접미사 배열과 LCP 배열",
      "brief_explain": "접미사 배열은 어떤 문자열의 시작 인덱스에 따른 접미사들을 사전순으로 정렬한 배열이고 LCP 배열은 두 접미사의 최대 공통 접두사의 길이인 LCP를 모은 배열을 의미해.",
      "detail_explain": "접미사 배열은 어떤 문자열의 시작 인덱스에 따른 접미사들을 사전순으로 정렬한 배열이고 LCP 배열은 두 접미사의 최대 공통 접두사의 길이인 LCP를 모은 배열을 의미해. 접미사 배열은 단순히 접미사를 구하고 정렬을 하면 O(N^2logN)이 걸리고 접미사 배열들을 직접 비교해서 LCP 배열을 구하면 O(N^2)이 걸리기에 각각 O(Nlog^2N), O(N)이 걸리는 방법을 구현해서 풀어야 하는 문제가 있어.",
      "level": "중급",
      "parent": "문자열"
    },
    {
      "name": "희소 배열",
      "brief_explain": "희소 배열은 배열에 속한 원소의 위치가 연속적이지 않은 배열을 말해.",
      "detail_explain": "희소 배열은 배열에 속한 원소의 위치가 연속적이지 않은 배열로 배열의 의미있는 정보보다 비어있는 정보가 더 많은 배열을 의미해. 그렇기에 의미있는 정보만 모아서 활용을 하는 기법을 쓸 수 있어. 비슷한 종류로는 희소 행렬이 있어." ,
      "level": "중급",
      "parent": "자료 구조"
    },
    {
      "name": "최소 비용 최대 유량",
      "brief_explain": "최소 비용을 구하여 그 최소 비용에 해당하는 간선으로의 최대 유량을 구하는 알고리즘이야.",
      "detail_explain": "최소 비용을 구하여 그 최소 비용에 해당하는 간선으로의 최대 유량을 구하는 알고리즘이야. 최소 비용이란 최단 거리를 구하는 문제라 볼 수 있고 최단 거리를 통해 네트워크나 그래프의 최대 지나가는 양(유량)을 구하는 알고리즘이야. 이때 비용이 음수가 될 수 있기에 음수가 포함된 최단거리를 구하는 알고리즘(벨몬포드, SPFA)을 통해 구할 수 있어.",
      "level": "중급",
      "parent": "그래프 이론"
    },
    {
      "name": "제곱근 분할법",
      "brief_explain": "특정 구간의 쿼리를 O(√N)에 처리하는 알고리즘이야.",
      "detail_explain": "구간을 √N개로 분할하여 관리하여 특정 구간의 쿼리를 O(√N)에 처리할 수 있도록 만드는 알고리즘이야. 이를 이용해 구간의 최댓값, 최솟값, 구간합 등을 구하거나 응용하여 Mo's 알고리즘의 기반이 돼.",
      "level": "고급",
      "parent": null
    },
    {
      "name": "작은 집합에서 큰 집합으로 합치는 테크닉",
      "brief_explain": "작은 집합에서 큰 집합으로 합치는 테크닉",
      "detail_explain": "작은 집합에서 큰 집합으로 합치는 테크닉",
      "level": "고급",
      "parent": null
    },
    {
      "name": "유클리드 호제법",
      "brief_explain": "두 수의 최대공약수를 구하는 알고리즘이야.",
      "detail_explain": "두 수의 최대공약수를 구하는 알고리즘이야. MOD 연산(두 값을 나눈 나머지를 구하는 연산)을 반복해서 O(log(n+m))으로 최대공약수를 구할 수 있어.",
      "level": "초급",
      "parent": "수학"
    },
    {
      "name": "덱",
      "brief_explain": "덱은 양쪽 끝 모두 원소를 넣거나 뺄 수 있는 자료구조야.",
      "detail_explain":  "덱은 양쪽 끝 모두 원소를 넣거나 뺄 수 있는 자료구조야. 앞/뒤 모두 원소를 추가/제거/확인 모두 O(1)의 시간복잡도를 가지고 있어. 스택과 큐 성질을 모두 가지고 있고 배열이나 라이브러리를 통해 구현할 수 있어.",
      "level": "초급",
      "parent":  "자료 구조"
    },
    {
      "name": "확률론",
      "brief_explain": "난수를 발생시켜 진행과정을 결정하는 알고리즘이야. 흔히 동전을 던진다고 표현하지.",
      "detail_explain":  "난수를 발생시켜 진행과정을 결정하는 알고리즘이야. 흔히 동전을 던진다고 표현하지만 실제로는 의사난수 생성기를 사용해. 알고리즘의 성능을 평균적으로 향상시키기 위해 난수를 사용하고 그렇기 때문에 알고리즘의 성능은 확률변수이며, 확률변수의 기댓값이 실제로 원하는 성능이야. 알고리즘 성능의 최악의 경우는 일어날 확률이 극히 작기 때문에 대부분 무시하게 돼.",
      "level": "고급",
      "parent":  "수학"
    },
    {
      "name": "런타임 전의 전처리",
      "brief_explain": "런타임이 실행되기전에 전처리를 통해 문제를 푸는 방법이야.",
      "detail_explain":  "런타임이 실행되기전에 필요한 데이터나 구조, 연산 등을 미리 처리를 해놓아 불필요한 시간을 아끼거나 여러가지 방법을 응용하여 푸는 방법이야.",
      "level": "중급",
      "parent":  null
    },
    {
      "name": "스프라그–그런디 정리",
      "brief_explain": "게임 이론 중 하나로 게임판의 상태를 각각 하나의 자연수 (그런디 수)로 치환할 수 있다는 것이 스프라그-그런디 정리야.",
      "detail_explain":  "게임 이론 중 하나로 게임판의 상태를 각각 하나의 자연수 (그런디 수)로 치환할 수 있다는 것이 스프라그-그런디 정리야. 이를 통해 각각의 상태에 따른 최적의 경우를 구해서 다이나믹 프로그래밍을 통해 게임 이론 문제를 풀 수 있어.",
      "level": "중급",
      "parent":  "게임 이론"
    },
    {
      "name": "매개 변수 탐색",
      "brief_explain": "최적화 문제를 결정 문제로 풀 수 있도록 하는 알고리즘이야.",
      "detail_explain":  "어떤 상황에서 최적인 값을 찾아야 할 때 조건이 만족됐다는 것을 true 조건이 만족하지 않은 것을 flase로 취급하여 결정 문제로 변환을 하고 그 중 조건을 만족하는 최댓값을 구하여 최적값을 구하는 알고리즘이야. 최적화 문제를 결정 문제처럼 바꾸어 이분 탐색을 하는 거라 생각하면 되지 그래서 O(logN)으로 풀수가 있어.",
      "level": "중급",
      "parent":  null
    },
    {
      "name": "가장 긴 증가하는 부분 수열: O(n log n)",
      "brief_explain": "가장 긴 증가하는 부분 수열을 구하는 알고리즘으로 다이나믹 프로그래밍으론 O(N^2)이지만 이진탐색을 사용하면 O(NlogN)으로 구할 수 있어.",
      "detail_explain":  "가장 긴 증가하는 부분 수열을 구하는 알고리즘으로 다이나믹 프로그래밍으론 O(N^2)이지만 i번째 원소 직전에 올 수 있는 원소들중 가장 길게 만들 수 있는 것을 찾을 때, 이진탐색을 사용해 O(NlogN)으로 구할 수 있어.",
      "level": "초급",
      "parent":  "이진 탐색"
    }
  ]
}